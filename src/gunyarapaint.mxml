<?xml version="1.0" encoding="utf-8"?>
<mx:Application
    xmlns:mx="http://www.adobe.com/2006/mxml"
    xmlns:ui="org.libspark.gunyarapaint.ui.v1.*"
    layout="absolute" width="100%" height="100%"
    preinitialize="onPreinitialize(event)"
    creationComplete="onCreationComplete(event)"
    applicationComplete="onApplicationComplete(event)"
    removedFromStage="onRemove(event)"
    borderStyle="solid" cornerRadius="0" borderColor="#333333"
    backgroundGradientAlphas="[1.0, 1.0]" backgroundGradientColors="[#cccccc, #cccccc]"
    implements="org.libspark.gunyarapaint.framework.ui.IApplication"
    alpha="1.0">
    <mx:Script>
        <![CDATA[
            import com.hurlant.crypto.Crypto;
            import com.hurlant.crypto.symmetric.ICipher;
            import com.hurlant.crypto.symmetric.IVMode;
            import com.hurlant.crypto.symmetric.PKCS5;
            
            import mx.controls.Alert;
            import mx.core.UITextField;
            import mx.events.FlexEvent;
            import mx.managers.PopUpManager;
            
            import org.libspark.gunyarapaint.framework.LayerBitmapCollection;
            import org.libspark.gunyarapaint.framework.Painter;
            import org.libspark.gunyarapaint.framework.Pen;
            import org.libspark.gunyarapaint.framework.Recorder;
            import org.libspark.gunyarapaint.framework.UndoStack;
            import org.libspark.gunyarapaint.framework.events.CommandEvent;
            import org.libspark.gunyarapaint.framework.modules.CanvasModuleContext;
            import org.libspark.gunyarapaint.framework.modules.CircleModule;
            import org.libspark.gunyarapaint.framework.modules.DropperModule;
            import org.libspark.gunyarapaint.framework.modules.FloodFillModule;
            import org.libspark.gunyarapaint.framework.modules.FreeHandModule;
            import org.libspark.gunyarapaint.framework.modules.ICanvasModule;
            import org.libspark.gunyarapaint.framework.modules.LineModule;
            import org.libspark.gunyarapaint.framework.modules.PixelModule;
            import org.libspark.gunyarapaint.ui.events.CanvasModuleEvent;
            import org.libspark.gunyarapaint.ui.v1.IController;
            import org.libspark.gunyarapaint.ui.v1.MovableCanvasModule;
            
            private var m_bytes:ByteArray;
            private var m_recorder:Recorder;
            private var m_context:CanvasModuleContext;
            private var m_module:ICanvasModule;
            private var m_commit:uint;
            private var m_windows:Vector.<IController>;
            
            private var basex:uint = 0;
            private var basey:uint = 0;
            private var baseWidth:uint = 0;
            private var baseHeight:uint = 0;
            
            private var oekakiId:uint;
            private var redirectUrl:String;
            
            //private var _logger:GPLogger;
            
            private const MAX_CANVAS_WIDTH:uint = 500;
            private const MAX_CANVAS_HEIGHT:uint = 500;
            private const MIN_CANVAS_WIDTH:uint = 16;
            private const MIN_CANVAS_HEIGHT:uint = 16;
            private const DEBUG:Boolean = true;
            
            public const ALERT_TITLE:String = 'お絵カキコ';
            
            public function setModule(value:String):void
            {
                if (hasEventListener(CanvasModuleEvent.BEFORE_CHANGE))
                    dispatchEvent(new CanvasModuleEvent(CanvasModuleEvent.BEFORE_CHANGE));
                m_module = m_context.getModule(value);
                if (m_module == null) {
                    throw new IllegalOperationError(value
                        + " is not the ICanvasModule implemented module");
                }
                if (hasEventListener(CanvasModuleEvent.AFTER_CHANGE))
                    dispatchEvent(new CanvasModuleEvent(CanvasModuleEvent.AFTER_CHANGE));
            }
            
            public function get module():ICanvasModule
            {
                return m_module;
            }
            
            public function get moduleName():String
            {
                switch (m_module.name) {
                    case CircleModule.CIRCLE:
                        return "円描画ツール";
                    case DropperModule.DROPPER:
                        return "スポイトツール";
                    case FloodFillModule.FLOOD_FILL:
                        return "塗りつぶしツール";
                    case FreeHandModule.FREE_HAND:
                        return "手書き(消しゴム)ツール";
                    case LineModule.LINE:
                        return "直線ツール";
                    case PixelModule.PIXEL:
                        return "ドットツール";
                    default:
                        return "謎のツール";
                }
            }
            
            public function get supportedBlendModes():Array
            {
                return blendModes.toArray();
            }
            
            public function get layers():LayerBitmapCollection
            {
                return m_recorder.layers;
            }
            
            public function get pen():Pen
            {
                return m_recorder.pen;
            }
            
            public function get undoStack():UndoStack
            {
                return m_recorder.undoStack;
            }
            
            public function get canvasWidth():uint
            {
                return m_recorder.width;
            }
            
            public function get canvasHeight():uint
            {
                return m_recorder.height;
            }
            
            public function get canvasView():Sprite
            {
                return m_recorder.view;
            }
            
            public function get commitCount():uint
            {
                return m_commit;
            }
            
            public function get recorder():Recorder
            {
                return m_recorder;
            }
            
            public function resetWindowsPosition():void
            {
                for (var i:String in m_windows) {
                    m_windows[i].resetWindow();
                }
            }
            
            public function load(bytes:ByteArray, password:String):void
            {
                var passwordBytes:ByteArray = new ByteArray();
                bytes.position = 0;
                bytes.endian = Endian.BIG_ENDIAN;
                passwordBytes.writeUTFBytes(password);
                var cipher:ICipher = Crypto.getCipher("aes", passwordBytes, new PKCS5());
                try {
                    var ivMode:IVMode = IVMode(cipher);
                    var ivBytes:ByteArray = ByteArray(bytes.readObject());
                    var dataBytes:ByteArray = ByteArray(bytes.readObject());
                    ivMode.IV = ivBytes;
                    cipher.decrypt(dataBytes);
                    dataBytes.inflate();
                    dataBytes.readBytes(m_bytes);
                    // TODO: 実装
                    // var log:GPLogger = GPLogger.deserialize(s);
                }
                catch (e:Error) {
                    trace(e.message);
                    Alert.show("指定されたファイルからログを復元することが出来ませんでした", ALERT_TITLE);
                }
            }
            
            public function save(bytes:ByteArray, password:String):void
            {
                var dataBytes:ByteArray = new ByteArray();
                var passwordBytes:ByteArray = new ByteArray();
                bytes.endian = Endian.BIG_ENDIAN;
                passwordBytes.writeUTFBytes(password);
                dataBytes.writeBytes(m_bytes);
                dataBytes.deflate();
                var cipher:ICipher = Crypto.getCipher("aes", passwordBytes, new PKCS5());
                cipher.encrypt(dataBytes);
                bytes.writeObject(IVMode(cipher).IV);
                bytes.writeObject(dataBytes);
                bytes.position = 0;
            }
            
            public function confirmUnload(bool:Boolean):void
            {
                if (ExternalInterface.available) {
                    try {
                        ExternalInterface.call("changeAlertOnUnload", bool);
                    } catch (e:SecurityError) {
                    } catch (e:Error) {
                    }
                }
            }
            
            private function onPreinitialize(event:FlexEvent):void
            {
                var width:int = 0;
                var height:int = 0;
                var undoBufferSize:int = 0;
                if (DEBUG) {
                    /*
                    parameters['oekakiId'] = 23724;
                    parameters['baseImgUrl'] = 'http://dic.nicovideo.jp/oekaki_layers/23724';
                    parameters['baseImgInfoUrl'] = 'http://dic.nicovideo.jp/oekaki_info/23724';
                    */
                    parameters['postUrl'] = 'http://dic.dev.nicovideo.jp/';
                    parameters['cookie'] = 'cookie';
                    parameters['magic'] = 'magic';
                    parameters['redirectUrl'] = 'http://dic.dev.nicovideo.jp/';
                    parameters['undoBufferSize'] = 16;
                    parameters['canvasWidth'] = 417;
                    parameters['canvasHeight'] = 317;
                }
                
                width = int(parameters['canvasWidth']);
                height = int(parameters['canvasHeight']);
                undoBufferSize = int(parameters['undoBufferSize']);
                
                m_bytes = new ByteArray();
                m_recorder = Recorder.create(m_bytes, width, height, undoBufferSize);
                m_context = new CanvasModuleContext(m_recorder);
                m_module = m_context.getModule(FreeHandModule.FREE_HAND);
                m_commit = 0;
                m_recorder.addEventListener(CommandEvent.COMMITTED, onCommit);
            }
            
            private function onCommit(event:CommandEvent):void
            {
                trace(event.command);
                m_commit++;
            }
            
            private function onCreationComplete(event:FlexEvent):void
            {
                var width:uint = 0;
                var height:uint = 0;
                var undoBufferSize:uint = 0;
                
                if (DEBUG) {
                    // debug buttons
                    //logPlayButton.addEventListener(FlexEvent.BUTTON_DOWN, playLogHandler);
                    versionLabel.text += 'debug';
                    //logPlayButton.visible = true;
                    //checkPngButton.visible = true;
                }
                
                /*
                enabled = false;
                canvasController.enabled = false;
                penController.enabled = false;
                layerWindow.enabled = false;
                */
                
                // ポップアップさせて、そいつらの初期位置を覚える
                PopUpManager.addPopUp(canvasController, this);
                PopUpManager.addPopUp(penController, this);
                PopUpManager.addPopUp(layerController, this);
                PopUpManager.addPopUp(toolController, this);
                PopUpManager.addPopUp(formController, this);
                m_windows = new Vector.<IController>();
                m_windows.push(
                    canvasController,
                    penController,
                    layerController,
                    toolController,
                    formController
                );
                
                if (parameters['postUrl'] && parameters['cookie'] && parameters['magic'] && parameters['redirectUrl']) {
                    //postOekakiButton.enabled = true;
                    redirectUrl = parameters['redirectUrl'];
                }
                if (parameters['undoBufferSize']) {
                    undoBufferSize = int(parameters['undoBufferSize']);
                    if (undoBufferSize < 0) {
                        Alert.show('最大アンドゥ回数が少なすぎます。', ALERT_TITLE);      
                    }
                    if (undoBufferSize > 32) {
                        Alert.show('最大アンドゥ回数が多すぎます。', ALERT_TITLE);      
                    }
                }
                else {
                    return;
                }
                if (parameters['oekakiId'] && parameters['baseImgUrl']) {
                    oekakiId = uint(parameters['oekakiId']);
                    //new Com().loadURL(parameters['baseImgUrl'], getBaseImgHandler);
                }
                else {
                    if (parameters['canvasWidth'] && parameters['canvasHeight']) {
                        width = int(parameters['canvasWidth']);
                        height = int(parameters['canvasHeight']);
                        if (width < MIN_CANVAS_WIDTH || height < MIN_CANVAS_HEIGHT) {
                            Alert.show('キャンバスサイズが小さすぎます。', ALERT_TITLE);
                            return;
                        }
                        if (width > MAX_CANVAS_WIDTH || height > MAX_CANVAS_HEIGHT) {
                            Alert.show('キャンバスサイズが大きすぎます。', ALERT_TITLE);
                            return;
                        }
                    } else {
                        return;
                    }
                }
                m_context.add(new MovableCanvasModule(m_recorder, canvasController));
            }
            
            private function onApplicationComplete(event:FlexEvent):void
            {
                stage.addEventListener(KeyboardEvent.KEY_DOWN, onKeyDown);  
                stage.addEventListener(KeyboardEvent.KEY_UP, onKeyUp);  
                //stage.addEventListener(MouseEvent.MOUSE_UP, onMouseUp);
                //stage.addEventListener(MouseEvent.MOUSE_OUT, onMouseUp); // これを入れるとマズい。
            }
            
            private function onRemove(event:Event):void
            {
                m_recorder.removeEventListener(CommandEvent.COMMITTED, onCommit);
                stage.removeEventListener(KeyboardEvent.KEY_DOWN, onKeyDown);  
                stage.removeEventListener(KeyboardEvent.KEY_UP, onKeyUp);  
                //stage.removeEventListener(MouseEvent.MOUSE_UP, onMouseUp);
                //stage.removeEventListener(MouseEvent.MOUSE_OUT, onMouseUp);
            }
            
            // canvasでの外のmouseUpをcanvasに通知  
            private function onMouseUp(evt:MouseEvent):void
            {
                module.interrupt(evt.localX, evt.localY);
            }
            
            private function get isShortCut():Boolean
            {
                return stage.focus is mx.core.UITextField;
            }
            
            private function onKeyDown(evt:KeyboardEvent):void
            {
                if (isShortCut)
                    return;
                switch (evt.keyCode) {
                    case Keyboard.CONTROL:
                        penController.pen = DropperModule.DROPPER;
                        break;
                    case Keyboard.SHIFT:
                        break;
                    case Keyboard.SPACE:
                        penController.pen = MovableCanvasModule.MOVABLE_CANVAS;
                        break;
                    case 48: // 0
                    case 96: // ten-key 0
                        evt.shiftKey ? toolController.setRotate(0) : toolController.setZoom(1);
                        break;
                    case 65: // a
                        // Aキーの状態 = 押下中
                        m_module.shouldDrawCircleClockwise = true;
                        break;
                    case 73: // i
                        resetWindowsPosition();
                        break;
                    case 77: // m
                        m_module.horizontalMirror(Painter.ALL_LAYERS);
                        break;
                    case 81: // q
                        // Qキーの状態 = 押下中
                        m_module.shouldDrawCircleCounterClockwise = true;
                        break;
                    case 82: // r
                        // Rキーの状態 = 押下中
                        m_module.shouldDrawFromEndPoint = true;
                        break;
                    // 20090905-haku2 ins start
                    case 84: // t
                        // Tキーの状態 = 押下中
                        m_module.shouldDrawFromStartPoint = true;
                        break;
                    // 20090905-haku2 ins end
                    case 89: // y
                        m_module.redo();
                        break;
                    case 90: // z
                        m_module.undo();
                        break;
                    case 107: // ten key +
                        // +
                        toolController.setZoom(toolController.canvasZoom.value + 1);
                        break;
                    case 109: // ten key -
                        // -
                        toolController.setZoom(toolController.canvasZoom.value - 1);
                        break;
                    case 187:
                        if (evt.shiftKey)
                            // +
                            toolController.setZoom(toolController.canvasZoom.value + 1);
                        break;
                    case 189:
                        // -
                        toolController.setZoom(toolController.canvasZoom.value - 1);
                        break;
                    case 49: // 1
                    case 50: // 2
                    case 51: // 3
                    case 52: // 4
                    case 53: // 5
                    case 54: // 6
                    case 55: // 7
                    case 56: // 8
                    case 57: // 9
                        if (!evt.shiftKey)// 念のため SHIFTキー対応 (テンキーのほうは放置)
                            penController.currentThickness = evt.keyCode - 48;
                        break;
                    case 97: // ten-key 1
                    case 98: // ten-key 2
                    case 99: // ten-key 3
                    case 100: // ten-key 4
                    case 101: // ten-key 5
                    case 102: // ten-key 6
                    case 103: // ten-key 7
                    case 104: // ten-key 8
                    case 105: // ten-key 9
                        penController.currentThickness = evt.keyCode - 96;
                        break;
                    case 45: // INS
                        if (!evt.shiftKey)
                            toolController.setRotate(0);
                        break;
                    default:
                        // Alert('' + evt.keyCode);
                        break;
                }
            }
            
            private function onKeyUp(evt:KeyboardEvent):void
            {
                if (isShortCut)
                    return;
                switch (evt.keyCode) {
                    case Keyboard.CONTROL:
                        penController.reset();
                        break;
                    case Keyboard.SPACE:
                        penController.reset();
                        break;
                    case 65: // a
                        // Aキーの状態 = 解放
                        m_module.shouldDrawCircleClockwise = false;
                        break;
                    case 81: // q
                        // Qキーの状態 = 解放
                        m_module.shouldDrawCircleCounterClockwise = false;
                        break;
                    case 82: // r
                        // Rキーの状態 = 解放
                        m_module.shouldDrawFromEndPoint = false;
                        break;
                    case 84: // t
                        // Tキーの状態 = 解放
                        m_module.shouldDrawFromStartPoint = false;
                        break;
                    return;
                }
            }
        ]]>
    </mx:Script>
    <mx:ArrayCollection id="blendModes">
        <mx:Object label="通常" data="{BlendMode.NORMAL}" />
        <mx:Object label="比較(暗)" data="{BlendMode.DARKEN}" />
        <mx:Object label="乗算" data="{BlendMode.MULTIPLY}" />
        <mx:Object label="比較(明)" data="{BlendMode.LIGHTEN}" />
        <mx:Object label="スクリーン" data="{BlendMode.SCREEN}" />
        <mx:Object label="覆い焼き" data="{BlendMode.ADD}" />
        <mx:Object label="オーバーレイ" data="{BlendMode.OVERLAY}" />
        <mx:Object label="ハードライト" data="{BlendMode.HARDLIGHT}" />
        <mx:Object label="差の絶対値" data="{BlendMode.DIFFERENCE}" />
        <mx:Object label="除外" data="{BlendMode.SUBTRACT}" />
        <mx:Object label="反転" data="{BlendMode.INVERT}" />
    </mx:ArrayCollection>
    <mx:Image source="@Embed('./gunyara-paint_logo.png')" alpha="0.5" right="10" bottom="10"/>
    <ui:FormController id="formController" title="投稿フォーム"  x="10" y="10" height="169" width="486"/>
    <ui:ToolController id="toolController" left="504" y="10" title="補助ツール" />
    <ui:PenController id="penController" x="10" y="223" layout="absolute" title="ペン" height="450" />
    <ui:CanvasController id="canvasController" x="146" y="223" width="379" height="410" layout="absolute" title="キャンバス" />
    <ui:LayerController x="533" y="223" layout="absolute" title="レイヤー" id="layerController" height="312" />
    <mx:Label id="versionLabel" text="{Painter.PAINTER_VERSION_STRING}" right="10" bottom="10" alpha="0.5"/>
</mx:Application>
