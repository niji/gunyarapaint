<?xml version="1.0" encoding="utf-8"?>
<mx:Application
    xmlns:mx="http://www.adobe.com/2006/mxml"
    xmlns:ui="org.libspark.gunyarapaint.ui.v1.*"
    layout="absolute" width="100%" height="100%"
    preinitialize="onPreinitialize(event)"
    applicationComplete="onApplicationComplete(event)"
    removedFromStage="onRemove(event)"
    borderStyle="solid" cornerRadius="0" borderColor="#333333"
    backgroundGradientAlphas="[1.0, 1.0]" backgroundGradientColors="[#cccccc, #cccccc]"
    implements="org.libspark.gunyarapaint.framework.ui.IApplication"
    alpha="1.0">
    <mx:Script>
        <![CDATA[
            import com.adobe.images.PNGEncoder;
            
            import mx.controls.Alert;
            import mx.core.IFlexDisplayObject;
            import mx.core.UITextField;
            import mx.events.FlexEvent;
            import mx.managers.PopUpManager;
            
            import org.libspark.gunyarapaint.framework.LayerBitmapCollection;
            import org.libspark.gunyarapaint.framework.Painter;
            import org.libspark.gunyarapaint.framework.Pen;
            import org.libspark.gunyarapaint.framework.Recorder;
            import org.libspark.gunyarapaint.framework.UndoStack;
            import org.libspark.gunyarapaint.framework.events.CommandEvent;
            import org.libspark.gunyarapaint.framework.modules.CanvasModuleContext;
            import org.libspark.gunyarapaint.framework.modules.CircleModule;
            import org.libspark.gunyarapaint.framework.modules.DropperModule;
            import org.libspark.gunyarapaint.framework.modules.FloodFillModule;
            import org.libspark.gunyarapaint.framework.modules.FreeHandModule;
            import org.libspark.gunyarapaint.framework.modules.ICanvasModule;
            import org.libspark.gunyarapaint.framework.modules.LineModule;
            import org.libspark.gunyarapaint.framework.modules.PixelModule;
            import org.libspark.gunyarapaint.ui.events.CanvasModuleEvent;
            import org.libspark.gunyarapaint.ui.v1.IController;
            import org.libspark.gunyarapaint.ui.v1.MovableCanvasModule;
            
            [Bindable]
            [Embed(source="../assets/images/icon_dropper.png")]
            public var dropperIcon:Class;
            
            [Bindable]
            [Embed(source="../assets/images/icon_hand_open.png")]
            public var handOpenIcon:Class;
            
            public const ALERT_TITLE:String = "お絵カキコ";
            
            private const MAX_CANVAS_WIDTH:uint = 500;
            private const MAX_CANVAS_HEIGHT:uint = 500;
            private const MIN_CANVAS_WIDTH:uint = 16;
            private const MIN_CANVAS_HEIGHT:uint = 16;
            private const DEBUG:Boolean = true;
            
            public function setCanvasModule(value:String):void
            {
                if (hasEventListener(CanvasModuleEvent.BEFORE_CHANGE))
                    dispatchEvent(new CanvasModuleEvent(CanvasModuleEvent.BEFORE_CHANGE));
                m_module = m_context.getModule(value);
                if (m_module == null) {
                    throw new IllegalOperationError(value
                        + " is not the ICanvasModule implemented module");
                }
                if (hasEventListener(CanvasModuleEvent.AFTER_CHANGE))
                    dispatchEvent(new CanvasModuleEvent(CanvasModuleEvent.AFTER_CHANGE));
            }
            
            public function get canvasModule():ICanvasModule
            {
                return m_module;
            }
            
            public function get canvasModuleName():String
            {
                switch (m_module.name) {
                    case CircleModule.CIRCLE:
                        return "円描画ツール";
                    case DropperModule.DROPPER:
                        return "スポイトツール";
                    case FloodFillModule.FLOOD_FILL:
                        return "塗りつぶしツール";
                    case FreeHandModule.FREE_HAND:
                        return "手書き(消しゴム)ツール";
                    case LineModule.LINE:
                        return "直線ツール";
                    case PixelModule.PIXEL:
                        return "ドットツール";
                    default:
                        return "謎のツール";
                }
            }
            
            public function get supportedBlendModes():Array
            {
                return blendModes.toArray();
            }
            
            public function get layers():LayerBitmapCollection
            {
                return m_recorder.layers;
            }
            
            public function get pen():Pen
            {
                return m_recorder.pen;
            }
            
            public function get undoStack():UndoStack
            {
                return m_recorder.undoStack;
            }
            
            public function get canvasWidth():uint
            {
                return m_recorder.width;
            }
            
            public function get canvasHeight():uint
            {
                return m_recorder.height;
            }
            
            public function get commitCount():uint
            {
                return m_commit;
            }
            
            public function resetWindowsPosition():void
            {
                for (var i:String in m_windows) {
                    m_windows[i].resetWindow();
                }
            }
            
            public function load(bytes:ByteArray):void
            {
                bytes.position = 0;
                bytes.endian = Endian.BIG_ENDIAN;
                bytes.inflate();
                var dataBytes:ByteArray = bytes.readObject();
                var rect:Object = bytes.readObject();
                var bitmapBytes:ByteArray = bytes.readObject();
                var metadata:Object = bytes.readObject();
                var controllerData:Object = bytes.readObject();
                var w:uint = rect.width;
                var h:uint = rect.height;
                var bitmapData:BitmapData = new BitmapData(w, h, true, 0x0);
                bitmapData.setPixels(new Rectangle(0, 0, w, h), bitmapBytes);
                m_recorder.load(bitmapData, metadata);
                dataBytes.readBytes(m_bytes);
                for (var i:String in m_windows) {
                    var controller:IController = m_windows[i];
                    var value:Object = controllerData[controller.name];
                    controller.load(value);
                }
            }
            
            public function save(bytes:ByteArray):void
            {
                var bitmapData:BitmapData = m_recorder.newLayerBitmapData;
                var metadata:Object = {};
                var rect:Rectangle = bitmapData.rect;
                m_recorder.save(bitmapData, metadata);
                bytes.endian = Endian.BIG_ENDIAN;
                bytes.writeObject(m_bytes);
                bytes.writeObject(rect);
                bytes.writeObject(bitmapData.getPixels(rect));
                bytes.writeObject(metadata);
                var controllerData:Object = {};
                for (var i:String in m_windows) {
                    var value:Object = {};
                    var controller:IController = m_windows[i];
                    controller.save(value);
                    controllerData[controller.name] = value;
                }
                bytes.writeObject(controllerData);
                bytes.deflate();
                bytes.position = 0;
            }
            
            public function confirmUnload(bool:Boolean):void
            {
                if (ExternalInterface.available) {
                    try {
                        ExternalInterface.call("changeAlertOnUnload", bool);
                    }
                    catch (e:Error) {
                        Alert.show(e.message, ALERT_TITLE);
                    }
                }
            }
            
            private function onPreinitialize(event:FlexEvent):void
            {
                if (DEBUG) {
                    /*
                    parameters["oekakiId"] = 23724;
                    parameters["baseImgUrl"] = "http://dic.nicovideo.jp/oekaki_layers/23724";
                    parameters["baseImgInfoUrl"] = "http://dic.nicovideo.jp/oekaki_info/23724";
                    */
                    parameters["postUrl"] = "http://dic.dev.nicovideo.jp/";
                    parameters["cookie"] = "cookie";
                    parameters["magic"] = "magic";
                    parameters["redirectUrl"] = "http://dic.dev.nicovideo.jp/";
                    parameters["undoBufferSize"] = 16;
                    parameters["canvasWidth"] = 417;
                    parameters["canvasHeight"] = 317;
                }
                
                if (parameters["postUrl"] &&
                    parameters["cookie"] &&
                    parameters["magic"] &&
                    parameters["redirectUrl"]) {
                    //postOekakiButton.enabled = true;
                    redirectUrl = parameters["redirectUrl"];
                }
            }
            
            private function onApplicationComplete(event:FlexEvent):void
            {
                if (DEBUG) {
                    // debug buttons
                    //logPlayButton.addEventListener(FlexEvent.BUTTON_DOWN, playLogHandler);
                    versionLabel.text += "debug";
                    //logPlayButton.visible = true;
                    //checkPngButton.visible = true;
                }
                
                /*
                enabled = false;
                canvasController.enabled = false;
                penController.enabled = false;
                layerWindow.enabled = false;
                */
                
                var width:uint = 0;
                var height:uint = 0;
                var undoBufferSize:uint = 0;
                undoBufferSize = int(parameters["undoBufferSize"]);
                if (undoBufferSize < 0) {
                    Alert.show("最大アンドゥ回数が少なすぎます。", ALERT_TITLE);   
                    enabled = true;
                    return;
                }
                else if (undoBufferSize > 32) {
                    Alert.show("最大アンドゥ回数が多すぎます。", ALERT_TITLE);      
                    enabled = true;
                    return;
                }
                if (parameters["oekakiId"] && parameters["baseImgUrl"]) {
                    oekakiId = uint(parameters["oekakiId"]);
                    //new Com().loadURL(parameters["baseImgUrl"], getBaseImgHandler);
                }
                else {
                    width = int(parameters["canvasWidth"]);
                    height = int(parameters["canvasHeight"]);
                    if (width < MIN_CANVAS_WIDTH || height < MIN_CANVAS_HEIGHT) {
                        Alert.show("キャンバスサイズが小さすぎます。", ALERT_TITLE);
                        enabled = false;
                        return;
                    }
                    else if (width > MAX_CANVAS_WIDTH || height > MAX_CANVAS_HEIGHT) {
                        Alert.show("キャンバスサイズが大きすぎます。", ALERT_TITLE);
                        enabled = false;
                        return;
                    }
                }
                m_bytes = new ByteArray();
                m_recorder = Recorder.create(m_bytes, width, height, undoBufferSize);
                m_context = new CanvasModuleContext(m_recorder);
                m_module = m_context.getModule(FreeHandModule.FREE_HAND);
                m_commit = 0;
                m_recorder.addEventListener(CommandEvent.COMMITTED, onCommit);
                m_context.registerModule(new MovableCanvasModule(m_recorder, canvasController));
                m_windows = new Vector.<IController>();
                m_windows.push(
                    canvasController,
                    penController,
                    layerController,
                    toolController,
                    formController
                );
                for (var i:String in m_windows) {
                    var controller:IController = m_windows[i];
                    controller.init(this);
                    PopUpManager.addPopUp(IFlexDisplayObject(controller), this);
                }
                stage.addEventListener(KeyboardEvent.KEY_DOWN, onKeyDown);
                stage.addEventListener(KeyboardEvent.KEY_UP, onKeyUp);
            }
            
            private function onRemove(event:Event):void
            {
                m_recorder.removeEventListener(CommandEvent.COMMITTED, onCommit);
                stage.removeEventListener(KeyboardEvent.KEY_DOWN, onKeyDown);  
                stage.removeEventListener(KeyboardEvent.KEY_UP, onKeyUp);  
                //stage.removeEventListener(MouseEvent.MOUSE_UP, onMouseUp);
                //stage.removeEventListener(MouseEvent.MOUSE_OUT, onMouseUp);
            }
            
            private function onCommit(event:CommandEvent):void
            {
                trace(event.command);
                m_commit++;
            }
            
            private function onKeyDown(evt:KeyboardEvent):void
            {
                if (isForcusedOnTextField)
                    return;
                switch (evt.keyCode) {
                    case Keyboard.CONTROL:
                        penController.pen = DropperModule.DROPPER;
                        break;
                    case Keyboard.SHIFT:
                        break;
                    case Keyboard.SPACE:
                        penController.pen = MovableCanvasModule.MOVABLE_CANVAS;
                        break;
                    case 48: // 0
                    case 96: // ten-key 0
                        evt.shiftKey ? toolController.setRotate(0) : toolController.setZoom(1);
                        break;
                    case 65: // a
                        // Aキーの状態 = 押下中
                        m_module.shouldDrawCircleClockwise = true;
                        break;
                    case 73: // i
                        resetWindowsPosition();
                        break;
                    case 77: // m
                        m_module.horizontalMirror(Painter.ALL_LAYERS);
                        break;
                    case 81: // q
                        // Qキーの状態 = 押下中
                        m_module.shouldDrawCircleCounterClockwise = true;
                        break;
                    case 82: // r
                        // Rキーの状態 = 押下中
                        m_module.shouldDrawFromEndPoint = true;
                        break;
                    // 20090905-haku2 ins start
                    case 84: // t
                        // Tキーの状態 = 押下中
                        m_module.shouldDrawFromStartPoint = true;
                        break;
                    // 20090905-haku2 ins end
                    case 88: // x
                        exportFile();
                        break;
                    case 89: // y
                        try {
                            m_module.redo();
                        }
                        catch (e:Error) {
                            Alert.show("やり直しが出来ません", ALERT_TITLE);
                        }
                        break;
                    case 90: // z
                        try {
                            m_module.undo();
                        }
                        catch (e:Error) {
                            Alert.show("巻き戻しが出来ません", ALERT_TITLE);
                        }
                        break;
                    case 107: // ten key +
                        // +
                        toolController.setZoom(toolController.canvasZoom.value + 1);
                        break;
                    case 109: // ten key -
                        // -
                        toolController.setZoom(toolController.canvasZoom.value - 1);
                        break;
                    case 187:
                        if (evt.shiftKey)
                            // +
                            toolController.setZoom(toolController.canvasZoom.value + 1);
                        break;
                    case 189:
                        // -
                        toolController.setZoom(toolController.canvasZoom.value - 1);
                        break;
                    case 49: // 1
                    case 50: // 2
                    case 51: // 3
                    case 52: // 4
                    case 53: // 5
                    case 54: // 6
                    case 55: // 7
                    case 56: // 8
                    case 57: // 9
                        if (!evt.shiftKey)// 念のため SHIFTキー対応 (テンキーのほうは放置)
                            penController.currentThickness = evt.keyCode - 48;
                        break;
                    case 97: // ten-key 1
                    case 98: // ten-key 2
                    case 99: // ten-key 3
                    case 100: // ten-key 4
                    case 101: // ten-key 5
                    case 102: // ten-key 6
                    case 103: // ten-key 7
                    case 104: // ten-key 8
                    case 105: // ten-key 9
                        penController.currentThickness = evt.keyCode - 96;
                        break;
                    case 45: // INS
                        if (!evt.shiftKey)
                            toolController.setRotate(0);
                        break;
                    default:
                        // Alert("" + evt.keyCode);
                        break;
                }
            }
            
            private function onKeyUp(evt:KeyboardEvent):void
            {
                if (isForcusedOnTextField)
                    return;
                switch (evt.keyCode) {
                    case Keyboard.CONTROL:
                        penController.reset();
                        break;
                    case Keyboard.SPACE:
                        penController.reset();
                        break;
                    case 65: // a
                        // Aキーの状態 = 解放
                        m_module.shouldDrawCircleClockwise = false;
                        break;
                    case 81: // q
                        // Qキーの状態 = 解放
                        m_module.shouldDrawCircleCounterClockwise = false;
                        break;
                    case 82: // r
                        // Rキーの状態 = 解放
                        m_module.shouldDrawFromEndPoint = false;
                        break;
                    case 84: // t
                        // Tキーの状態 = 解放
                        m_module.shouldDrawFromStartPoint = false;
                        break;
                    return;
                }
            }
            
            private function get isForcusedOnTextField():Boolean
            {
                return stage.focus is mx.core.UITextField;
            }
            
            private function exportFile():void
            {
                if (m_file == null) {
                    var name:String = (new Date()).getTime() + ".png";
                    var bitmapData:BitmapData = canvasController.exportBitmapData();
                    var data:ByteArray = PNGEncoder.encode(bitmapData);
                    bitmapData.dispose();
                    m_file = new FileReference();
                    m_file.addEventListener(Event.CANCEL, onExportCancel);
                    m_file.addEventListener(Event.COMPLETE, onExportComplete);
                    m_file.save(data, name);
                }
            }
            
            private function onExportCancel(event:Event):void
            {
                m_file.removeEventListener(Event.CANCEL, onExportCancel);
                m_file.removeEventListener(Event.COMPLETE, onExportComplete);
                m_file = null;
            }
            
            private function onExportComplete(event:Event):void
            {
                Alert.show("書き込みました", ALERT_TITLE);
                m_file.removeEventListener(Event.CANCEL, onExportCancel);
                m_file.removeEventListener(Event.COMPLETE, onExportComplete);
                m_file = null;
            }
            
            private var m_bytes:ByteArray;
            private var m_recorder:Recorder;
            private var m_context:CanvasModuleContext;
            private var m_module:ICanvasModule;
            private var m_file:FileReference;
            private var m_commit:uint;
            private var m_windows:Vector.<IController>;
            
            private var oekakiId:uint;
            private var redirectUrl:String;
        ]]>
    </mx:Script>
    <mx:ArrayCollection id="blendModes">
        <mx:Object label="通常" data="{BlendMode.NORMAL}" />
        <mx:Object label="比較(暗)" data="{BlendMode.DARKEN}" />
        <mx:Object label="乗算" data="{BlendMode.MULTIPLY}" />
        <mx:Object label="比較(明)" data="{BlendMode.LIGHTEN}" />
        <mx:Object label="スクリーン" data="{BlendMode.SCREEN}" />
        <mx:Object label="覆い焼き" data="{BlendMode.ADD}" />
        <mx:Object label="オーバーレイ" data="{BlendMode.OVERLAY}" />
        <mx:Object label="ハードライト" data="{BlendMode.HARDLIGHT}" />
        <mx:Object label="差の絶対値" data="{BlendMode.DIFFERENCE}" />
        <mx:Object label="除外" data="{BlendMode.SUBTRACT}" />
        <mx:Object label="反転" data="{BlendMode.INVERT}" />
    </mx:ArrayCollection>
    <mx:Image source="@Embed('../assets/images/gunyara-paint_logo.png')" alpha="0.5" right="10" bottom="10"/>
    <ui:FormController id="formController" title="投稿フォーム"  x="10" y="10" height="169" width="486"/>
    <ui:ToolController id="toolController" left="504" y="10" title="補助ツール" />
    <ui:PenController id="penController" x="10" y="223" layout="absolute" title="ペン" height="450" />
    <ui:CanvasController id="canvasController" x="146" y="223" width="379" height="410" layout="absolute" title="キャンバス" />
    <ui:LayerController x="533" y="223" layout="absolute" title="レイヤー" id="layerController" height="312" />
    <mx:Label id="versionLabel" text="{Painter.PAINTER_VERSION_STRING}" right="10" bottom="10" alpha="0.5"/>
</mx:Application>
