<?xml version="1.0" encoding="utf-8"?>
<mx:Application
    xmlns:mx="http://www.adobe.com/2006/mxml"
    xmlns:ui="com.github.niji.gunyarapaint.ui.v1.*"
    layout="absolute" width="100%" height="100%"
    preinitialize="onPreinitialize(event)"
    applicationComplete="onApplicationComplete(event)"
    borderStyle="solid" cornerRadius="0" borderColor="#333333"
    backgroundGradientAlphas="[1.0, 1.0]" backgroundGradientColors="[#cccccc, #cccccc]"
    implements="com.github.niji.framework.ui.IApplication"
    alpha="1.0" xmlns:net="com.github.niji.gunyarapaint.ui.v1.net.*">
    <mx:Script>
        <![CDATA[
            import com.adobe.images.PNGEncoder;
            import com.adobe.serialization.json.JSON;
            import com.adobe.serialization.json.JSONParseError;
            import com.github.niji.framework.LayerList;
            import com.github.niji.framework.Marshal;
            import com.github.niji.framework.Painter;
            import com.github.niji.framework.Pen;
            import com.github.niji.framework.Recorder;
            import com.github.niji.framework.UndoStack;
            import com.github.niji.framework.Version;
            import com.github.niji.framework.events.CommandEvent;
            import com.github.niji.framework.i18n.TranslatorRegistry;
            import com.github.niji.framework.modules.CanvasModuleContext;
            import com.github.niji.framework.modules.CircleModule;
            import com.github.niji.framework.modules.DropperModule;
            import com.github.niji.framework.modules.FloodFillModule;
            import com.github.niji.framework.modules.FreeHandModule;
            import com.github.niji.framework.modules.ICanvasModule;
            import com.github.niji.framework.modules.LineModule;
            import com.github.niji.framework.modules.PixelModule;
            import com.github.niji.framework.ui.IController;
            import com.github.niji.gunyarapaint.ui.events.CanvasModuleEvent;
            import com.github.niji.gunyarapaint.ui.i18n.GetTextTranslator;
            import com.github.niji.gunyarapaint.ui.v1.CopyrightWindow;
            import com.github.niji.gunyarapaint.ui.v1.FileController;
            import com.github.niji.gunyarapaint.ui.v1.MovableCanvasModule;
            import com.github.niji.gunyarapaint.ui.v1.PNGExporter;
            import com.github.niji.gunyarapaint.ui.v1.net.LoadingDialog;
            import com.github.niji.gunyarapaint.ui.v1.net.Parameters;
            import com.rails2u.gettext.GetText;
            
            import flash.net.navigateToURL;
            
            import mx.controls.Alert;
            import mx.core.IFlexDisplayObject;
            import mx.core.UITextField;
            import mx.events.CloseEvent;
            import mx.events.FlexEvent;
            import mx.events.MenuEvent;
            import mx.managers.PopUpManager;
            
            [Bindable]
            [Embed(source="../assets/images/icon_dropper.png")]
            public var dropperIcon:Class;
            
            [Bindable]
            [Embed(source="../assets/images/icon_hand_open.png")]
            public var handOpenIcon:Class;
            
            [Bindable]
            [Embed(source="../assets/langs.xml", mimeType="application/octet-stream")]
            private var languages:Class;
            
            [Bindable]
            [Embed(source="../assets/config.xml", mimeType="application/octet-stream")]
            private var config:Class;
            
            private const MAX_CANVAS_WIDTH:uint = 500;
            private const MAX_CANVAS_HEIGHT:uint = 500;
            private const MIN_CANVAS_WIDTH:uint = 16;
            private const MIN_CANVAS_HEIGHT:uint = 16;
            
            public function setCanvasModule(value:String):void
            {
                if (hasEventListener(CanvasModuleEvent.BEFORE_CHANGE))
                    dispatchEvent(new CanvasModuleEvent(CanvasModuleEvent.BEFORE_CHANGE));
                m_module.unload();
                m_module = m_context.getModule(value);
                if (m_module == null) {
                    throw new IllegalOperationError(value
                        + " is not the ICanvasModule implemented module");
                }
                m_module.load();
                if (hasEventListener(CanvasModuleEvent.AFTER_CHANGE))
                    dispatchEvent(new CanvasModuleEvent(CanvasModuleEvent.AFTER_CHANGE));
            }
            
            public function get canvasModule():ICanvasModule
            {
                return m_module;
            }
            
            public function get canvasModuleName():String
            {
                switch (m_module.name) {
                    case CircleModule.CIRCLE:
                        return _("Circle module");
                    case DropperModule.DROPPER:
                        return _("Dropper module");
                    case FloodFillModule.FLOOD_FILL:
                        return _("Flood fill module");
                    case FreeHandModule.FREE_HAND:
                        return _("Freehand (or Eraser) module");
                    case LineModule.LINE:
                        return _("Line module");
                    case PixelModule.PIXEL:
                        return _("Pixel module");
                    default:
                        return _("Unknown module");
                }
            }
            
            public function get supportedBlendModes():Array
            {
                return m_blendModes.slice();
            }
            
            public function get layers():LayerList
            {
                return m_recorder.layers;
            }
            
            public function get pen():Pen
            {
                return m_recorder.pen;
            }
            
            public function get undoStack():UndoStack
            {
                return m_recorder.undoStack;
            }
            
            public function get canvasWidth():uint
            {
                return m_recorder.width;
            }
            
            public function get canvasHeight():uint
            {
                return m_recorder.height;
            }
            
            public function get commitCount():uint
            {
                return m_commit;
            }
            
            public function get enabledDevelopmentSupport():Boolean
            {
                return m_development;
            }
            
            public function resetWindowsPosition():void
            {
                for (var i:String in m_windows) {
                    m_windows[i].resetWindow();
                }
            }
            
            public function newMarshal():Marshal
            {
                return new Marshal(m_recorder, m_windows);
            }
            
            public function load(bytes:ByteArray):void
            {
                try {
                    newMarshal().load(bytes, m_bytes);
                    m_module.reset();
                }
                catch (e:Error) {
                    showAlert(e.message, m_title);
                }
            }
            
            public function save(bytes:ByteArray):void
            {
                try {
                    newMarshal().save(bytes, m_bytes);
                }
                catch (e:Error) {
                    showAlert(e.message, m_title);
                }
            }
            
            public function fillParameters(param:Parameters):void
            {
                if (!m_development && commitCount == 0)
                    throw new ArgumentError(_("The canvas is not drawn. You should draw the canvas."));
                if (!parameters.postUrl    ||
                    !parameters.cookie     ||
                    !parameters.magic      ||
                    !parameters.redirectUrl)
                    throw new ArgumentError(_("Request cannot accept for the invalid state. This error should not be occured"));
                var layers:LayerList = m_recorder.layers;
                var bitmapData:BitmapData = new BitmapData(layers.width, layers.height);
                bitmapData.draw(layers.view);
                var layerBitmap:BitmapData = layers.newLayerBitmapData;
                var metadata:Object = {};
                layers.save(layerBitmap, metadata);
                metadata.log_count = commitCount;
                metadata.pen_details = penController.dataForPost;
                metadata.undo_buffer_size = m_recorder.undoStack.size;
                param.cookie = parameters.cookie;
                param.magic = parameters.magic;
                param.refererId = parameters.oekakiId;
                param.imageBytes = PNGEncoder.encode(bitmapData);
                param.layerImageBytes = PNGEncoder.encode(layerBitmap);
                param.logBytes = m_recorder.newBytes();
                param.logCount = commitCount;
                param.metadata = metadata;
                bitmapData.dispose();
            }
            
            public function showAlert(message:String, title:String):void
            {
                m_lockHandlingKeyboard = true;
                Alert.show(message, title, Alert.OK, null, onClose);
            }
            
            public function set shouldAlertOnUnload(value:Boolean):void
            {
                if (ExternalInterface.available) {
                    try {
                        ExternalInterface.call("changeAlertOnUnload", value);
                    }
                    catch (e:Error) {
                        Alert.show(e.message, m_title);
                    }
                }
            }
            
            private function restoreCanvas(metadata:Object):void
            {
                var width:int = metadata.width;
                var height:int = metadata.height;
                var ready:Boolean = postInitialize(width, height);
                // If ready is false, an error has occured.
                if (ready) {
                    m_lockHandlingKeyboard = true;
                    var from:UndoStack = m_recorder.undoStack;
                    m_recorder.load(m_baseImage, metadata);
                    var to:UndoStack = m_recorder.undoStack;
                    if (metadata.pen_details != null)
                        penController.palettes = metadata.pen_details[0];
                    toolController.swapEventListener(from, to);
                    layerController.swapEventListener(from, to);
                    layerController.update();
                    enabled = ready;
                    m_lockHandlingKeyboard = false;
                }
            }
            
            private function postInitialize(width:int, height:int):Boolean
            {
                var undoBufferSize:int = int(parameters["undoBufferSize"]);
                if (undoBufferSize < 1) {
                    showAlert(_("Too small count of the max of undo." +
					             "(required is %s and minimum is %s)", 
                                 undoBufferSize, 1), m_title);   
                    return false;
                }
                else if (undoBufferSize > 32) {
                    showAlert(_("Too many count of the max of undo." +
					             "(required is %s and maximum is %s)", undoBufferSize, 32), m_title);      
                    return false;
                }
                else if (width < MIN_CANVAS_WIDTH || height < MIN_CANVAS_HEIGHT) {
                    showAlert(_("Too small size of the canvas." +
					             "(required is %s x %s and minimum is %s x %s)",
								 width, height, MIN_CANVAS_WIDTH, MIN_CANVAS_HEIGHT), m_title);
                    return false;
                }
                else if (width > MAX_CANVAS_WIDTH || height > MAX_CANVAS_HEIGHT) {
                    showAlert(_("Too big size of the canvas." +
					             "(required is %s x %s and minimum is %s x %s)",
                                 width, height, MAX_CANVAS_WIDTH, MAX_CANVAS_HEIGHT), m_title);
                    return false;
                }
                m_bytes = new ByteArray();
                m_recorder = Recorder.create(m_bytes, width, height, undoBufferSize);
                m_context = new CanvasModuleContext(m_recorder);
                m_module = m_context.getModule(FreeHandModule.FREE_HAND);
                m_commit = 0;
                m_recorder.addEventListener(CommandEvent.COMMITTED, onCommit);
                m_context.registerModule(new MovableCanvasModule(m_recorder, canvasController));
                m_exporter = new PNGExporter();
                m_exporter.addEventListener(Event.COMPLETE, onExportComplete);
                m_windows = new Vector.<IController>(5, true);
                m_windows[0] = canvasController;
                m_windows[1] = penController;
                m_windows[2] = layerController;
                m_windows[3] = toolController;
                m_windows[4] = formController;
                m_lockHandlingKeyboard = false;
                for (var i:String in m_windows) {
                    var controller:IController = m_windows[i];
                    controller.init(this);
                    PopUpManager.addPopUp(IFlexDisplayObject(controller), this);
                }
                stage.addEventListener(KeyboardEvent.KEY_DOWN, onKeyDown);
                stage.addEventListener(KeyboardEvent.KEY_UP, onKeyUp);
                return true;
            }
            
            private function addLoaderEvents(loader:EventDispatcher):void
            {
                loadingDialog.visible = true;
                loadingDialog.centerize(this);
                loadingDialog.setProgressSource(loader);
                PopUpManager.addPopUp(loadingDialog, this);
                loader.addEventListener(IOErrorEvent.IO_ERROR, onIOError);
                loader.addEventListener(SecurityErrorEvent.SECURITY_ERROR, onSecurityError);
            }
            
            private function removeLoaderEvents(loader:EventDispatcher):void
            {
                loadingDialog.visible = false;
                PopUpManager.removePopUp(loadingDialog);
                loader.removeEventListener(IOErrorEvent.IO_ERROR, onIOError);
                loader.removeEventListener(SecurityErrorEvent.SECURITY_ERROR, onSecurityError);
            }
            
            private function onPreinitialize(event:FlexEvent):void
            {
                var configXml:XML = new XML(new config());
                if (configXml.@stage != "production") {
                    for each (var item:XML in configXml.children()) {
                        parameters[item.name()] = item.toString();
                    }
                    m_development = true;
                }
                // The default state is disabled
                enabled = false;
                GetText.locale = parameters["language"] || "ja_jp";
                GetText.initLangFile(new XML(new languages()));
                TranslatorRegistry.install(new GetTextTranslator());
                m_title = _("Oekakiko");
                m_blendModes = [
                    { "label": _("Normal"),     "data": BlendMode.NORMAL     },
                    { "label": _("Darken"),     "data": BlendMode.DARKEN     },
                    { "label": _("Multiply"),   "data": BlendMode.MULTIPLY   },
                    { "label": _("Lighten"),    "data": BlendMode.LIGHTEN    },
                    { "label": _("Screen"),     "data": BlendMode.SCREEN     },
                    { "label": _("Add"),        "data": BlendMode.ADD        },
                    { "label": _("Overlay"),    "data": BlendMode.OVERLAY    },
                    { "label": _("Hardlight"),  "data": BlendMode.HARDLIGHT  },
                    { "label": _("Difference"), "data": BlendMode.DIFFERENCE },
                    { "label": _("Subtract"),   "data": BlendMode.SUBTRACT   },
                    { "label": _("Invert"),     "data": BlendMode.INVERT     },
                ];
            }
            
            private function onApplicationComplete(event:FlexEvent):void
            {
                if (m_development)
                    versionLabel.text += " with development mode";
                var oekakiId:uint = uint(parameters["oekakiId"]);
                if (oekakiId > 0 && parameters["baseImgUrl"]) {
                    var loader:Loader = new Loader();
                    addLoaderEvents(loader.contentLoaderInfo);
                    loader.contentLoaderInfo.addEventListener(Event.COMPLETE, onLoadImage);
                    loader.load(new URLRequest(parameters.baseImgUrl));
                    loadingDialog.title = _("Loading the image layers...");
                }
                else {
                    // It's not continued
                    var width:int = int(parameters["canvasWidth"]);
                    var height:int = int(parameters["canvasHeight"]);
                    enabled = postInitialize(width, height);
                }
            }
            
            private function onCommit(event:CommandEvent):void
            {
                //trace(event.command);
                m_commit++;
            }
            
            private function onKeyDown(event:KeyboardEvent):void
            {
                if (m_lockHandlingKeyboard || isForcusedOnTextField)
                    return;
                var keyCode:uint = event.keyCode;
                switch (keyCode) {
                    case Keyboard.CONTROL:
                        penController.saveState();
                        penController.pen = DropperModule.DROPPER;
                        break;
                    case Keyboard.SPACE:
                        penController.saveState();
                        penController.pen = MovableCanvasModule.MOVABLE_CANVAS;
                        break;
                    case 48: // 0
                    case 96: // ten-key 0
                        if (event.shiftKey)
                            toolController.setRotate(0);
                        else
                            toolController.setZoom(1);
                        break;
                    case 65: // a (pressing)
                        m_module.shouldDrawCircleClockwise = true;
                        break;
                    case 73: // i
                        resetWindowsPosition();
                        break;
                    case 77: // m
                        m_module.horizontalMirror(Painter.ALL_LAYERS);
                        break;
                    case 81: // q (pressing)
                        m_module.shouldDrawCircleCounterClockwise = true;
                        break;
                    case 82: // r (pressing)
                        m_module.shouldDrawFromEndPoint = true;
                        break;
                    case 84: // t (pressing)
                        m_module.shouldDrawFromStartPoint = true;
                        break;
                    case 88: // x
                        var bitmapData:BitmapData = canvasController.exportBitmapData();
                        m_exporter.save(bitmapData);
                        bitmapData.dispose();
                        break;
                    case 89: // y
                        try {
                            m_module.redo();
                        }
                        catch (e:Error) {
                            showAlert(e.message, m_title);
                        }
                        break;
                    case 90: // z
                        try {
                            m_module.undo();
                        }
                        catch (e:Error) {
                            showAlert(e.message, m_title);
                        }
                        break;
                    case 107: // ten key +
                        // +
                        toolController.setZoom(toolController.canvasZoom.value + 1);
                        break;
                    case 109: // ten key -
                        // -
                        toolController.setZoom(toolController.canvasZoom.value - 1);
                        break;
                    case 187:
                        // +
                        if (event.shiftKey)
                            toolController.setZoom(toolController.canvasZoom.value + 1);
                        break;
                    case 189:
                        // -
                        toolController.setZoom(toolController.canvasZoom.value - 1);
                        break;
                    case 49: // 1
                    case 50: // 2
                    case 51: // 3
                    case 52: // 4
                    case 53: // 5
                    case 54: // 6
                    case 55: // 7
                    case 56: // 8
                    case 57: // 9
                        // SHIFT + (NUM) is reserved
                        if (!event.shiftKey)
                            penController.currentThickness = keyCode - 48;
                        break;
                    case 97: // ten-key 1
                    case 98: // ten-key 2
                    case 99: // ten-key 3
                    case 100: // ten-key 4
                    case 101: // ten-key 5
                    case 102: // ten-key 6
                    case 103: // ten-key 7
                    case 104: // ten-key 8
                    case 105: // ten-key 9
                        penController.currentThickness = keyCode - 96;
                        break;
                    case 45: // INS
                        // INS + SHIFT is reserved
                        if (!event.shiftKey)
                            toolController.setRotate(0);
                        break;
                }
            }
            
            private function onKeyUp(evt:KeyboardEvent):void
            {
                if (m_lockHandlingKeyboard || isForcusedOnTextField)
                    return;
                switch (evt.keyCode) {
                    case Keyboard.CONTROL:
                    case Keyboard.SPACE:
                        penController.loadState();
                        break;
                    case 65: // a (released)
                        m_module.shouldDrawCircleClockwise = false;
                        break;
                    case 81: // q (released)
                        m_module.shouldDrawCircleCounterClockwise = false;
                        break;
                    case 82: // r (released)
                        m_module.shouldDrawFromEndPoint = false;
                        break;
                    case 84: // t (released)
                        m_module.shouldDrawFromStartPoint = false;
                        break;
                }
            }
            
            private function onClose(event:CloseEvent):void
            {
                m_lockHandlingKeyboard = false;
            }
            
            private function onExportComplete(event:Event):void
            {
                showAlert(_("Exporting the bitmap of the canvas to PNG has been completed."), m_title);
            }
            
            private function onClickImage():void
            {
                PopUpManager.addPopUp(new CopyrightWindow(), this, true);
            }
            
            private function onLoadImage(event:Event):void
            {
                var loaderInfo:LoaderInfo = LoaderInfo(event.target);
                loaderInfo.removeEventListener(Event.COMPLETE, onLoadImage);
                removeLoaderEvents(loaderInfo);
                m_baseImage = Bitmap(loaderInfo.content).bitmapData;
                if (parameters["baseImgInfoUrl"]) {
                    // from continued
                    var loader:URLLoader = new URLLoader();
                    addLoaderEvents(loader);
                    loader.addEventListener(Event.COMPLETE, onLoadImageInfo);
                    loader.load(new URLRequest(parameters.baseImgInfoUrl));
                    loadingDialog.title = _("Loading the image metadata...");
                }
                else {
                    // FIXME: Should be removed?
                    var metadata:Object = {
                        "width": m_baseImage.width,
                        "height": m_baseImage.height
                    };
                    restoreCanvas(metadata);
                }
            }
            
            private function onLoadImageInfo(event:Event):void
            {
                var loader:URLLoader = URLLoader(event.target);
                var metadata:Object = null;
                loader.removeEventListener(Event.COMPLETE, onLoadImageInfo);
                removeLoaderEvents(loader);
                try {
                    metadata = JSON.decode(String(loader.data));
                    restoreCanvas(metadata);
                }
                catch (e:JSONParseError) {
                    // should not be occured
                    showAlert(e.message, e.name);
                }
            }
            
            private function onIOError(event:IOErrorEvent):void
            {
                removeLoaderEvents(EventDispatcher(event.target));
                showAlert(_("IO error has occured. Try again: %s", event.text), event.type);
            }
            
            private function onSecurityError(event:SecurityErrorEvent):void
            {
                removeLoaderEvents(EventDispatcher(event.target));
                showAlert(_("Security error has occured. This error should not be occured: %s", event.text), event.type);
            }
            
            private function get isForcusedOnTextField():Boolean
            {
                return stage.focus is mx.core.UITextField;
            }
            
            private var m_baseImage:BitmapData;
            private var m_bytes:ByteArray;
            private var m_recorder:Recorder;
            private var m_context:CanvasModuleContext;
            private var m_module:ICanvasModule;
            private var m_exporter:PNGExporter;
            private var m_commit:uint;
            private var m_windows:Vector.<IController>;
            private var m_title:String;
            private var m_blendModes:Array;
            private var m_development:Boolean;
            private var m_lockHandlingKeyboard:Boolean;
        ]]>
    </mx:Script>
    <ui:DockMenu id="dockMenu" />
    <ui:FormController id="formController" title="書き込みフォーム"  x="10" y="44"/>
    <ui:ToolController id="toolController" left="504" y="44" title="補助ツール" />
    <ui:PenController id="penController" x="10" y="218" layout="absolute" title="ペンツール"/>
    <ui:CanvasController id="canvasController" x="146" y="218" width="379" height="410" layout="absolute" title="キャンバス" />
    <ui:LayerController x="533" y="218" layout="absolute" title="レイヤーツール" id="layerController" />
    <net:LoadingDialog id="loadingDialog" visible="false" />
    <mx:Label id="versionLabel" text="{Version.DATE_STRING}" right="10" bottom="10" alpha="0.5" click="onClickImage()"/>
</mx:Application>
